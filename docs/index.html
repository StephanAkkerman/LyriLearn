<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LyriLearn – Minimal</title>
  <link rel="stylesheet" href="https://unpkg.com/mvp.css" />
  <link rel="stylesheet" href="./styles.css" />
  <style>
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:1rem}
    .muted{color:#666}
    .time{font-variant-numeric:tabular-nums}
    .line{padding:.15rem 0}
    /* Simple UPOS-based coloring */
    .upos-NOUN{background:#e6f4ff}
    .upos-VERB{background:#e8ffe6}
    .upos-ADJ{background:#fff6e6}
    .upos-ADV{background:#f3e6ff}
    .token{padding:0 .15rem;border-radius:.25rem}
  </style>
</head>
<body>
<main>
  <header>
    <h1>LyriLearn</h1>
    <p class="muted">Dual-pane lyrics ↔ translation (backend API required)</p>
  </header>

  <section>
    <form id="qform">
      <label>Title <input name="title" required placeholder="Dara" /></label>
      <label>Artist <input name="artist" required placeholder="Artist Name" /></label>
      <div class="grid">
        <label>Source (L2) <input name="src" value="id" /></label>
        <label>Target (L1) <input name="dest" value="en" /></label>
      </div>
      <label>Backend URL <input id="backend" placeholder="http://localhost:8000" /></label>
      <label><input type="checkbox" id="pos" checked /> Include POS</label>
      <button>Load</button>
    </form>
  </section>

  <section id="legend" class="legend"></section>

  <section id="panes" hidden>
  <div id="pairs" class="pair-grid"></div>
</section>

</main>
<script>
const $ = s => document.querySelector(s);
const BACKEND_KEY = 'lyrilearn_backend_url';
$('#backend').value = localStorage.getItem(BACKEND_KEY) || 'http://localhost:8000';

const pairs = document.getElementById('pairs');
const legendBox = document.getElementById('legend');

const fmt = s => s == null ? "" : String(s);
const fmtTime = t => t == null ? "" : new Date(Math.floor(t*1000)).toISOString().substr(14,5);

// Human-friendly labels for UD tags
const UPOS_LABEL = {
  ADJ:'Adjective', ADP:'Adposition', ADV:'Adverb', AUX:'Auxiliary', CCONJ:'Coordinating conj.',
  DET:'Determiner', INTJ:'Interjection', NOUN:'Noun', NUM:'Numeral', PART:'Particle',
  PRON:'Pronoun', PROPN:'Proper noun', PUNCT:'Punctuation', SCONJ:'Subordinating conj.',
  SYM:'Symbol', VERB:'Verb', X:'Other'
};

document.getElementById('qform').addEventListener('submit', async (e) => {
  e.preventDefault();

  const fd = new FormData(e.target);
  const title  = fd.get('title');
  const artist = fd.get('artist');
  const src    = fd.get('src');   // L2
  const dest   = fd.get('dest');  // L1
  const wantPOS = document.getElementById('pos').checked;

  const backend = $('#backend').value.replace(/\/$/, '');
  localStorage.setItem(BACKEND_KEY, backend);

  const url = `${backend}/api/lyrics-annotated?title=${encodeURIComponent(title)}&artist=${encodeURIComponent(artist)}&lang=${encodeURIComponent(src)}&dest=${encodeURIComponent(dest)}&pos=${wantPOS?1:0}`;

  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    renderPairsAndLegend(data);
    document.getElementById('panes').hidden = false;
  } catch (err) {
    console.error('Fetch failed:', err);
    alert(`Request failed: ${err.message}`);
  }
});
function escapeHtml(s){return s.replace(/[&<>"']/g, m=>({ '&':'&nbsp;&','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));}

function renderPairsAndLegend(data) {
  pairs.innerHTML = '';
  const tagsSeen = new Set();

  data.lines.forEach((ln, lineIdx) => {
    // Build lookup: for each token index, which group ids it belongs to
    const gIdsL2 = new Map(); const gIdsL1 = new Map();
    (ln.groups || []).forEach((g, gi) => {
      const gid = `${lineIdx}-${gi}`;
      (g.l2 || []).forEach(i => {
        const arr = gIdsL2.get(i) || []; arr.push(gid); gIdsL2.set(i, arr);
      });
      (g.l1 || []).forEach(j => {
        const arr = gIdsL1.get(j) || []; arr.push(gid); gIdsL1.set(j, arr);
      });
    });

    // Left (L2) — per-token with UPOS color
    const left = document.createElement('div');
    left.className = 'cell';
    const tspan = `<span class="time">${fmtTime(ln.t)}</span> `;
    const l2html = (ln.tokens && ln.tokens.length)
      ? ln.tokens.map((tok, i) => {
          const upos = (tok.upos || 'X').toUpperCase();
          tagsSeen.add(upos);
          const cls = `token tok upos-${upos}`;
          const title = `${tok.lemma||''} · ${upos}${tok.feats?`\n${tok.feats}`:''}`;
          const groups = (gIdsL2.get(i) || []).join(' ');
          return `<span class="${cls}" title="${escapeHtml(title)}" data-side="l2" data-line="${lineIdx}" data-idx="${i}" data-g="${groups}">${escapeHtml(tok.text)}</span>`;
        }).join(' ')
      : escapeHtml(ln.l2 || '');
    left.innerHTML = tspan + l2html;

    // Right (L1) — tokenize spans even if no POS; color neutral
    const right = document.createElement('div');
    right.className = 'cell';
    const l1html = (ln.l1_tokens && ln.l1_tokens.length)
      ? ln.l1_tokens.map((tok, j) => {
          const groups = (gIdsL1.get(j) || []).join(' ');
          return `<span class="tok" data-side="l1" data-line="${lineIdx}" data-idx="${j}" data-g="${groups}">${escapeHtml(tok)}</span>`;
        }).join(' ')
      : escapeHtml(ln.l1 || '');
    right.innerHTML = l1html;

    pairs.appendChild(left);
    pairs.appendChild(right);
  });

  buildLegend(tagsSeen);
  wireHoverLinking();
}

// Hover linking: highlight all tokens sharing any group id with the hovered token
function wireHoverLinking() {
  pairs.addEventListener('mouseover', e => {
    const el = e.target.closest('.tok');
    if (!el) return;
    const groups = (el.dataset.g || '').trim().split(/\s+/).filter(Boolean);
    if (!groups.length) return;
    document.querySelectorAll('.tok').forEach(n => {
      const ng = (n.dataset.g || '');
      if (groups.some(g => ng.includes(g))) n.classList.add('hl');
    });
  });
  pairs.addEventListener('mouseout', () => {
    document.querySelectorAll('.tok.hl').forEach(n => n.classList.remove('hl'));
  });
}

function buildLegend(tagsSeen) {
  // Build chips only for tags present, in a consistent order
  const ORDER = ['NOUN','PROPN','VERB','AUX','ADJ','ADV','PRON','DET','ADP','CCONJ','SCONJ','NUM','PART','INTJ','SYM','PUNCT','X'];
  const tags = ORDER.filter(t => tagsSeen.has(t));
  if (!tags.length) { legendBox.innerHTML = ''; return; }

  legendBox.innerHTML = tags.map(t => {
    const label = UPOS_LABEL[t] || t;
    // Use a small swatch with the same CSS class color
    return `<span class="chip"><span class="swatch upos-${t}"></span>${label}</span>`;
  }).join('');
}
</script>
</body>
</html>
